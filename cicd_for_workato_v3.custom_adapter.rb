{
  title: "Workato Developer APIs",

  connection: {
    fields: [      
      {
        name: "workato_environments",
        label: "Workato environments",
        item_label: "Environment",
        list_mode: "static",
        list_mode_toggle: false,
        type: "array",
        of: "object",
        properties: [
          {
            name: "name",
            label: "Environment name",
            optional: false,
            control_type: "select",
            options: [
              %w[DEV DEV],
              %w[TEST TEST],              
              %w[PROD PROD]
            ],
            hint: "Select each environment only once. Modify SDK code if additional environments are needed."
          },
          {
            name: "data_center",
            label: "Data center",
            control_type: "select",
            default: "https://www.workato.com/api",
            optional: false,
            options: [
              ["US", "https://www.workato.com/api"],
              ["EU", "https://app.eu.workato.com/api"],
              ["SG", "https://app.sg.workato.com/api"],
              ["JP", "https://app.jp.workato.com/api"],
              ["AU", "https://app.au.workato.com/api"]
            ]
          },
          {
            name: "isProduction",
            label: "Is Production",
            type: "boolean",
            control_type: "checkbox",
            default: false,
            optional: true
          },          
          {
            name: "level",
            optional: false,
            type: "integer",
            control_type: "select",
            options: [
              %w(One 1),
              %w(Two 2),
              %w(Three 3),
              %w(Four 4),
              %w(Five 5),
              %w(Six 6),
              %w(Seven 7),
              %w(Eight 8),
              %w(Nine 9),
              %w(Ten 10)
            ]
          },
          {
            name: "api_token",
            label: "API Token",
            control_type: "password",
            optional: false,
            hint: "API Token is generated by creating an <a href=\"https://docs.workato.com/workato-api/api-clients.html\" target=\"_blank\">API Client</a>."
          }        
        ]
      }
    ],
    
    authorization: {
      type: "custom_auth",
    }
       
  },
  
  test: lambda do |connection|
    # Execute Connection Validations
    call("connection_validation", connection["workato_environments"]) 
    
    # Proceed if all validations return success
    connection["workato_environments"].each do |env|
      connect_res = get("#{env['data_center']}/users/me")
      .headers({ "Authorization": "Bearer #{env["api_token"]}" })
      connect_res.presence
    end     
  end,
  
  object_definitions: {
    package_details: {
      fields: lambda do
        [
          {
            name: "workato_environment",
            label: "Workato environment"
          },
          {
            name: "package_id",
            label: "Package ID"
          },
          {
            name: "error",
            label: "Error"
          },
          {
            name: "deployment_mode",
            label: "Deployment Mode"
          },           
          {
            name: "content",
            label: "Package content"
          }           
        ]
      end
    }, # package_details.end    
    environment_obj: {
      fields: lambda do
        [
          {name: "name"},
          {name: "isProduction", type: "boolean"},
          {name: "level", type: "integer"}
        ]
      end
    },
    build_package_obj: {
      fields: lambda do
        [
          {name: "id", type: "integer"},
          {name: "status"},
          {name: "deployment_mode"},
          {name: "workato_environment"},
          {name: "source_reference"},
          {name: "download_url"}
        ]
      end
    }
  },
  
  actions: {
    run_testcases_async: {
      title: "Run All Test Cases (Asynchronous)",
      subtitle: "Run All Configured Test Cases",
      
      help: "Use this action to Run All Configured Test Cases.",
      
      description: lambda do |input| 
        "Run <span class='provider'>All Test Cases</span> in " \
        "<span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| [
        {
          label: "Workato environment",
          type: "string",
          name: "workato_environment",
          control_type: "select",
          toggle_hint: "Select from list",
          pick_list: "environments",
          toggle_field: {
            name: "workato_environment",
            label: "Workato environment",
            type: "string",
            control_type: "text",
            optional: false,
            toggle_hint: "Custom value",
          },             
          optional: false,
          hint: "Select Environment"
        },{
          label: "asset_id",
          type: "string",
          name: "asset_id",
          control_type: "text",
          optional: true,
          hint: "Specify Asset ID whose test cases you want to trigger."
        },{
          label: "asset_type",
          type: "string",
          name: "asset_type",
          control_type: "text",
          optional: true,
          hint: "Specify Asset Type: rlcm, projects, folder, recipe or testcase"
        }]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        headers['Content-Type'] = 'application/json'
        
        payload = {}
        if input["asset_id"].present?
          payload["manifest_id"] = input["asset_id"].to_i if input["asset_type"] == "rlcm"
          payload["folder_id"] = input["asset_id"].to_i if input["asset_type"] == "projects"
          payload["folder_id"] = input["asset_id"].to_i if input["asset_type"] == "folder"
          payload["recipe_id"] = input["asset_id"].to_i if input["asset_type"] == "recipe"
          payload["test_case_ids"] = input["asset_id"] if input["asset_type"] == "testcase"
        end
        
        post("#{env_datacenter}/test_cases/run_requests")
        .headers(headers)
        .payload(payload)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}")
        end
      end, # execute.end
      
      output_fields: lambda do |object_definitions| [
        { name: "data", type: "object", properties: [
          { name: "id" },
          { name: "status" },
          { name: "user", type: "object", properties: [{ name: "id" }]},
          { name: "created_at" },
          { name: "updated_at" },
          { name: "results", type: "array", of: "object", properties: [
            { name: "recipe", type: "object", properties: [
              { name: "id" },
              { name: "name" }]},
            { name: "test_case", type: "object", properties: [
              { name: "id" },
              { name: "name" }]},
            { name: "job", type: "object", properties: [{ name: "id" }]},
            { name: "status" }]}]}]
      end # output_fields.end      
    }, # run_test_cases.end
    
    get_testcase_status: {
      title: "Get Test Case Status",
      subtitle: "Get Status of Running Test Cases",
      
      help: "Use this action to Get the Status of Running Test Cases.",
      
      description: lambda do |input| 
        "Get <span class='provider'>Status of Test Cases</span> in " \
        "<span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| [
        {
          label: "Workato environment",
          type: "string",
          name: "workato_environment",
          control_type: "select",
          toggle_hint: "Select from list",
          pick_list: "environments",
          toggle_field: {
            name: "workato_environment",
            label: "Workato environment",
            type: "string",
            control_type: "text",
            optional: false,
            toggle_hint: "Custom value",
          },             
          optional: false,
          hint: "Select Environment"
        },{
          label: "id",
          type: "string",
          name: "id",
          control_type: "text",
          optional: false,
          hint: "Get the status of a specified test case."
        }]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        testcase_endpoint = "#{env_datacenter}/test_cases/run_requests/"
        
        if input['id'].present?
          testcase_endpoint = testcase_endpoint + input['id']
        end
        
        get(testcase_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
      end, # execute.end
      
      output_fields: lambda do |object_definitions|[
        { name: "data", type: "object", properties: [
          { name: "id" },
          { name: "status" },
          { name: "user", type: "object", properties: [{ name: "id" }]},
          { name: "created_at" },
          { name: "updated_at" },
          { name: "coverage", type: "object", properties: [
            { name: "value" },
            { name: "total_actions_count" },
            { name: "total_visited_actions_count" },
            { name: "recipes", type: "array", of: "object", properties: [
              { name: "id" },
              { name: "version_no" },
              { name: "coverage", type: "object", properties: [
                { name: "value" },
                { name: "not_visited_actions", type: "array", of: "object", 
                  properties: [{ name: "step_number" }]}]}]}]},
          { name: "results", type: "array", of: "object",
            properties: [{ name: "recipe", type: "object", properties: [
              { name: "id" },
              { name: "name" }]},
              { name: "test_case", type: "object", properties: [
                { name: "id" },
                { name: "name" }]},
              { name: "job", type: "object", properties: [
                { name: "id" }]},
              { name: "status" }]}]}]
      end
    }, # run_test_cases.end
    
    get_recipe_testcases: {
      title: "Get All Test Cases of a Recipe",
      subtitle: "Get All Configured Test Cases in a Recipe",
      
      help: "Use this action to Get All Configured Test Cases in a Recipe.",
      
      description: lambda do |input| 
        "Get <span class='provider'>All Test Cases</span> for a Recipe in " \
        "<span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| [
        {
          label: "Workato environment",
          type: "string",
          name: "workato_environment",
          control_type: "select",
          toggle_hint: "Select from list",
          pick_list: "environments",
          toggle_field: {
            name: "workato_environment",
            label: "Workato environment",
            type: "string",
            control_type: "text",
            optional: false,
            toggle_hint: "Custom value",
          },             
          optional: false,
          hint: "Select Environment"
        },{
          label: "recipe_id",
          type: "integer",
          name: "recipe_id",
          control_type: "text",
          optional: false,
          hint: "Get all test cases for specified recipe."
        }]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        testcase_endpoint = "#{env_datacenter}/recipes/"
        
        if input['recipe_id'].present?
          testcase_endpoint = testcase_endpoint + input['recipe_id'] + "/test_cases"
        end
        
        get(testcase_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
      end, # execute.end
      
      output_fields: lambda do |object_definitions|[
        { name: "data", type: "object", properties: [
          { name: "id" },
          { name: "created_at" },
          { name: "updated_at" },
          { name: "description" },
          { name: "name" }]}]
      end
    }, # run_test_cases.end
    
    get_environments: {
      title: "Get Environments",
      subtitle: "Get list of configured environments",
      
      input_fields: lambda do |object_definitions, connection|
        [ 
          {
            name: "source_env",
            label: "Source Environment",
            control_type: "select",
            pick_list: "environments",
            optional: true,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "source_env",
              label: "Source Environment Reference",
              type: "string",
              control_type: "text",
              optional: true,
              toggle_hint: "Use Environment Name"              
            }    
          },
          {
            name: "exclude_prod",
            label: "Exclude Production",
            type: "boolean",
            control_type: "checkbox",
            optional: true,
            default: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "exclude_prod",
              label: "Exclude Production",
              type: "string",
              control_type: "text",
              optional: true,
              toggle_hint: "Use custom value"
            }  
          }
        ]
      end,
      
      execute: lambda do |connection, input|
        {
          "environments": call("get_target_environments", connection, input)
        }
          
      end,
      output_fields: lambda do |object_definitions, _connection|
        [ 
          {
            name: "environments",
            type: "array",
            of: "object",
            properties: object_definitions['environment_obj']
          }          
        ]
      end      
    },
    
    get_environment_by_name: {
      title: "Get Environment by Name",
      subtitle: "Get a specific environment by name",
      
      input_fields: lambda do |object_definitions, connection|
        [ 
          {
            name: "env_name",
            label: "Environment Name",
            control_type: "select",
            pick_list: "environments",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "env_name",
              label: "Environment Reference",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Environment Name"              
            }    
          }
        ]
      end, 
      
      execute: lambda do |connection, input|
        environment_hash = {}
        
        filter_env = connection['workato_environments'].where(name: input['env_name']).first
        if filter_env.present?
          environment_hash = {
            name: filter_env['name'],
            isProduction: filter_env['isProduction'].is_true? ? true : false,
            level: filter_env['level']
          }
        else
          error('Environment not found.')
        end
          
      end,
      output_fields: lambda do |object_definitions, _connection|
        object_definitions['environment_obj']
      end      
    },
    
    build_package_async: {
      title: "Build package (Asynchronous)",
      subtitle: "Build manifest or a project",
      
      help: "Use this action to build a manifest or project from an environment.",
      
      description: lambda do |input| 
        "Build <span class='provider'>package</span> from " \
        "Workato <span class='provider'>Environment</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        [ 
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }  
          },
          {
            name: "workato_environment",
            label: "Workato Environment",
            control_type: "select",
            pick_list: "environments",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Workato Environment Reference",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Environment Name"              
            }    
          },
          {
            name: "id",
            label: "ID",
            hint: "Source manifest or project/folder ID to build.",
            optional: false
          },
          {
            name: "description",
            label: "Description",
            hint: "Release description for documentation.",
            optional: true,
            ngIf: "input.deployment_mode == 'projects'",
          }
        ]
      end,      
      
      execute: lambda do |connection, input|
        
        headers = call("get_auth_headers", connection, input["workato_environment"])
        projects = (input["deployment_mode"] == "projects" ? true : false)
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        build_endpoint = projects ? "#{env_datacenter}/projects/f#{input["id"]}/build" : "#{env_datacenter}/packages/export/#{input["id"]}"
        build_body = projects ? { description:input["description"].to_s } : nil

        response = post(build_endpoint)
          .headers(headers)
          .request_body(build_body)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
        
        res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
        res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
        res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")
                 
        {
          "id": response['id'],
          "status": res_in_progress ? "in_progress" : (res_success ? "success" : "failed"),
          "deployment_mode": input["deployment_mode"],
          "workato_environment": input["workato_environment"],            
          "source_reference": (projects ? response["project_id"] : response["export_manifest_id"]),
          "download_url": response["download_url"]
        }

      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        object_definitions["build_package_obj"]
      end # output_fields.end
      
    }, # build_package_async.end
    
    get_build_package: {
      title: "Get build package",
      subtitle: "Get a build for a manifest or a project",
      
      help: "Use this action to get a build for a manifest or project from an environment.",
      
      description: lambda do |input| 
        "Get a build <span class='provider'>package</span> from " \
        "Workato <span class='provider'>Environment</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        [ 
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }  
          },
          {
            name: "workato_environment",
            label: "Workato Environment",
            control_type: "select",
            pick_list: "environments",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Workato Environment Reference",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Environment Name"              
            }    
          },
          {
            name: "id",
            label: "Build or Package ID",
            optional: false
          }
        ]
      end,      
      
      execute: lambda do |connection, input|
        
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        headers = call("get_auth_headers", connection, input["workato_environment"])
        projects = (input["deployment_mode"] == "projects" ? true : false)        
        status_endpoint = projects ? "#{env_datacenter}/project_builds/#{input["id"]}" : "#{env_datacenter}/packages/#{input["id"]}"       

        response = get(status_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end

        res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
        res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
        res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")
        
        {
          "id": response['id'],
          "status": res_in_progress ? "in_progress" : (res_success ? "success" : "failed"),
          "deployment_mode": input["deployment_mode"],
          "workato_environment": input["workato_environment"],            
          "source_reference": (projects ? response["project_id"] : response["export_manifest_id"]),
          "download_url": response["download_url"]
        }
        
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        object_definitions["build_package_obj"]
      end # output_fields.end
      
    }, # get_build_package.end 
    
    build_download_package: {
      title: "Build and download package",
      subtitle: "Build and download manifest or a project",
      
      help: "Use this action to build and export a manifest or project from the DEV environment.",
      
      description: lambda do |input| 
        "Build and download <span class='provider'>package</span> from " \
        "Workato <span class='provider'>DEV</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        [ 
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }  
          },
          {
            name: "workato_env",
            label: "Workato Environment",
            control_type: "select",
            pick_list: "environments",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_env",
              label: "Workato Environment Reference",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Environment Name"              
            }    
          },
          {
            name: "id",
            label: "ID",
            hint: "Source manifest or project/folder ID to build.",
            optional: false
          },
          {
            name: "description",
            label: "Description",
            hint: "Release description for documentation.",
            optional: true,
            ngIf: "input.deployment_mode == 'projects'",
          }
        ]
      end,      
      
      execute: lambda do |connection, input, eis, eos, continue|
     
        continue = {} unless continue.present?
        current_step = continue['current_step'] || 1
        max_steps = 10
        step_time = current_step * 10 # This helps us wait longer and longer as we increase in steps
        headers = call("get_auth_headers", connection, input["workato_env"])
        env_datacenter = call("get_environment_datacenter", connection, input["workato_env"])

        projects = (input["deployment_mode"] == "projects" ? true : false)      
        
        if current_step == 1 # First invocation
          # Projects API - https://docs.workato.com/workato-api/projects.html#build-a-project
          # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#export-package-based-on-a-manifest
          build_endpoint = projects ? "#{env_datacenter}/projects/f#{input["id"]}/build" : "#{env_datacenter}/packages/export/#{input["id"]}"
          build_body = projects ? { description:input["description"].to_s } : nil

          response = post(build_endpoint)
          .headers(headers)
          .request_body(build_body)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
          
          res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
          res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
          res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")

          # If job is in_progress, reinvoke after wait time
          if res_in_progress == true
            reinvoke_after(
              seconds: step_time, 
              continue: { 
                current_step: current_step + 1, 
                jobid: response['id']
              }
            )
          elsif res_failed
            err_msg = response["error"].blank? ? "Package build and download failed." : response["error"]
            error(err_msg)
          elsif res_success
            call("download_from_url", {
              "headers" => headers, 
              # Fix v2.1 "workato_environment" => input["workato_environment"],
              "workato_environment" => input["workato_env"],
              "download_url" => response["download_url"],
              "package_id" => response["id"],
              "deployment_mode" => input["deployment_mode"]
            })
          end # first_response_if.end
        
        # Subsequent invocations
        elsif current_step <= max_steps                 
          # Projects API - https://docs.workato.com/workato-api/projects.html#get-a-project-build
          # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#get-package-by-id
          status_endpoint = projects ? "#{env_datacenter}/project_builds/#{continue["jobid"]}" : "#{env_datacenter}/packages/#{continue["jobid"]}"

          response = get(status_endpoint)
          .headers(headers)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
          
          res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
          res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
          res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")
          
          if res_in_progress
              reinvoke_after(
                seconds: step_time, 
                continue: { 
                  current_step: current_step + 1, 
                  jobid: response['id']
                }
              )
          elsif res_failed
            err_msg = response["error"].blank? ? "Package build and download failed." : response["error"]
            error(err_msg)
          elsif res_success
            call("download_from_url", {
              "headers" => headers, 
              "workato_environment" => input["workato_env"],
              "download_url" => response["download_url"],
              "package_id" => response["id"],
              "deployment_mode" => input["deployment_mode"]              
            })
          end # subsequent_response_if.end

        else
          error("Job took too long!")
          
        end # outer.if.end
        
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        object_definitions["package_details"]
      end # output_fields.end
      
    }, # build_download_package.end    
    
    download_package: {
      title: "Download package",
      subtitle: "Download existing package from Workato",
      
      help: "Use this action to download an existing package from the DEV environment.",
      
      description: lambda do |input| 
        "Download <span class='provider'>package</span> from " \
        "Workato <span class='provider'>DEV</span>"
      end,
      
      input_fields: lambda do |object_definitions, connection, config_fields|
        [  
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }
          },
          {
            name: "workato_environment",
            label: "Workato Environment",
            control_type: "select",
            pick_list: "environments",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Workato Environment Reference",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Environment Name"              
            }    
          },
          {
            name: "id",
            label: "ID",
            hint: "Package or build ID to export.",
            optional: false            
          }
        ]
      end, 
      
      execute: lambda do |connection, input, eis, eos, continue|
        headers = call("get_auth_headers", connection, input["workato_environment"])

        projects = (input["deployment_mode"] == "projects" ? true : false)
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])

        # Projects API - https://docs.workato.com/workato-api/projects.html#get-a-project-build
        # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#get-package-by-id
        status_endpoint = projects ? "#{env_datacenter}/project_builds/#{input["id"]}" : "#{env_datacenter}/packages/#{input["id"]}"

        response = get(status_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end        

        res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")
        
        if res_success
          call("download_from_url", {
            "headers" => headers, 
            "workato_environment" => input["workato_environment"],
            "download_url" => response["download_url"],
            "package_id" => response["id"],
            "deployment_mode" => input["deployment_mode"]    
          })
        else{
          "workato_environment" => input["workato_environment"],
          "package_id" => response['id'],
          "error" => projects ? "" : response['error'].presence,
          "deployment_mode" => input["deployment_mode"]
        }
        end
    
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        object_definitions["package_details"]
      end # output_fields.end      
      
    }, # download_package.end
    
    deploy_package: {
      title: "Deploy package",
      subtitle: "Deploy package to Workato environment",
      
      help: "Use this action import a package to the selected environment. This is an asynchronous request and uses Workato long action. Learn more <a href=\"https://docs.workato.com/workato-api/recipe-lifecycle-management.html#import-package-into-a-folder\" target=\"_blank\">here</a>.",
      
      description: lambda do |input| 
        "Deploy <span class='provider'>package</span> to " \
        "Workato <span class='provider'>#{input["workato_environment"]}</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        mode = config_fields['deployment_mode']       
        [
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }
          },          
          {
            name: "id",
            label: "ID",
            hint: "Package or build ID to deploy.",
            optional: false
          },
          {
            label: "Source Environment",
            name: "src_environment",
            #ngIf: "input.deployment_mode == 'rlcm'",
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "src_environment",
              label: "Source Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter source environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Select source environment which would be 'Development' in ideal case."
          }, 
          {
            label: "Target Environment",
            name: "target_environment",
            ngIf: "input.deployment_mode == 'rlcm'",
            control_type: "select",
            pick_list: "target_environments",
            pick_list_params: { src_environment: 'src_environment' },
            toggle_hint: "Select from list",
            toggle_field: {
              name: "target_environment",
              label: "Target Environment",
              type: "string",
              control_type: "text",
              optional: true,
              hint: "Enter target environment.",
              toggle_hint: "Custom value",
            },        
            optional: true,
            hint: "Select target environment"
          },          
          {
            name: "folder_id",
            label: "Folder ID",
            hint: "Target environment folder ID to import package into.",
            ngIf: "input.deployment_mode == 'rlcm'",
            optional: true
          },                      
          {
            name: "env_type",
            label: "Environment type",
            hint: "Target environment type. Projects API currently supports only test and prod values.",
            control_type: "select",
            pick_list: "target_environment_types",
            ngIf: "input.deployment_mode == 'projects'",            
            optional: true
          },
          {
            name: "description",
            label: "Description",
            hint: "Deployment description for documentation.",
            optional: true,
            ngIf: "input.deployment_mode == 'projects'",
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        
        continue = {} unless continue.present?
        current_step = continue['current_step'] || 1
        max_steps = 10
        step_time = current_step * 10 # This helps us wait longer and longer as we increase in steps

        projects = (input["deployment_mode"] == "projects" ? true : false)
        
        # headers = projects ? call("get_auth_headers", connection, "DEV") : call("get_auth_headers", connection, "#{input["workato_environment"]}")
        headers = call("get_auth_headers", connection, "#{input["target_environment"]}")
        env_datacenter = call("get_environment_datacenter", connection, input["target_environment"])
        
        if current_step == 1 # First invocation
          # Projects API - https://docs.workato.com/workato-api/projects.html#deploy-a-project-build
          # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#export-package-based-on-a-manifest
          deploy_endpoint = projects ? "#{env_datacenter}/project_builds/#{input["id"]}/deploy?environment_type=#{input["env_type"]}" : "#{env_datacenter}/packages/import/#{input["folder_id"]}?restart_recipes=true"

          # For RLCM API, download package ID and use it for import
          deploy_body = ""
          if projects.is_true?
            deploy_body = { "description" => input["description"].to_s }
            headers["Content-Type"] = "application/json"
          else
            # Existing package download should always happen from DEV, hence ensure src_env_headers irrespective of API mode
            src_env_headers = call("get_auth_headers", connection, input["src_environment"])
            src_env_datacenter = call("get_environment_datacenter", connection, input["src_environment"])
            deploy_body_param = get("#{src_env_datacenter}/packages/#{input["id"]}/download")          
            .headers(src_env_headers)
            .ignore_redirection               
            .after_error_response(/.*/) do |_code, body, _header, message|
              error("#{message}: #{body}")
            end
            .after_response do |code, body, headers|
              {
                package_url: headers[:location]
              }
            end.response_format_raw
          
            deploy_body_res = call("download_from_url", {
              "headers" => headers, 
              "workato_environment" => input["src_environment"],
              "download_url" => deploy_body_param[:package_url],
              "package_id" => input["id"],
              "deployment_mode" => input["deployment_mode"]              
            })
            deploy_body = deploy_body_res[:content].encode('ASCII-8BIT')
            headers["Content-Type"] = "application/octet-stream"           
          end
          
          response = post(deploy_endpoint) 
            .headers(headers)
            .request_body(deploy_body)
            .after_error_response(/.*/) do |_, body, _, message|
              error("#{message}: #{body}") 
            end

          res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
          res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
          res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")          
          
          # If job is in_progress, reinvoke after wait time
          if res_in_progress
              reinvoke_after(
                seconds: step_time, 
                continue: { 
                  current_step: current_step + 1, 
                  jobid: response['id']
                }
              )
          elsif res_failed
            err_msg = response["error"].blank? ? "Package build and download failed." : response["error"]
            error(err_msg)            
          elsif res_success
            {
              status: projects ? response["state"] : response["status"],
              job_id: response["id"]
            }
          end # first_response_if.end
          
        # Subsequent invocations
        elsif current_step <= max_steps           
          # Projects API - https://docs.workato.com/workato-api/projects.html#get-a-deployment
          # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#get-package-by-id
          status_endpoint = projects ? "#{env_datacenter}/deployments/#{continue["jobid"]}" : "#{env_datacenter}/packages/#{continue["jobid"]}"

          response = get(status_endpoint)
          .headers(headers)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end

          res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
          res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
          res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")               
          
          if res_in_progress
              reinvoke_after(
                seconds: step_time, 
                continue: { 
                  current_step: current_step + 1, 
                  jobid: response['id']
                }
              )
          elsif res_failed
            err_msg = response["error"].blank? ? "Package build and download failed." : response["error"]
            error(err_msg)
          elsif res_success
            {
              status: projects ? response["state"] : response["status"],
              job_id: response["id"]
            }
          end # subsequent_response_if.end

        else
          error("Job #{continue["jobid"]} took too long!")          
          
        end # outer.if.end
        
      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
          { name: "status" },
          { name: "job_id" },
        ]
      end
    }, # deploy_package.end
    
    deploy_package_async: {
      title: "Deploy package (Asynchronous)",
      subtitle: "Deploy package to Workato environment asynchronously.",
      
      help: "Use this action import a package to the selected environment. This is an asynchronous request. Learn more <a href=\"https://docs.workato.com/workato-api/recipe-lifecycle-management.html#import-package-into-a-folder\" target=\"_blank\">here</a>.",
      
      description: lambda do |input| 
        "Deploy <span class='provider'>package</span> to " \
        "Workato <span class='provider'>#{input["workato_environment"]} asynchronously</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        mode = config_fields['deployment_mode']       
        [
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }
          },          
          {
            name: "id",
            label: "ID",
            hint: "Package or build ID to deploy.",
            optional: false
          },
          {
            label: "Source Environment",
            name: "src_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "src_environment",
              label: "Source Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter source environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter source environment."
          }, 
          {
            label: "Target Environment",
            name: "target_environment",
            control_type: "select",
            pick_list: "target_environments",
            pick_list_params: { src_environment: 'src_environment' },
            toggle_hint: "Select from list",
            toggle_field: {
              name: "target_environment",
              label: "Target Environment",
              type: "string",
              control_type: "text",
              optional: true,
              hint: "Enter target environment.",
              toggle_hint: "Custom value",
            },        
            optional: true,
            hint: "Enter target environment.",
          },          
          {
            name: "folder_id",
            label: "Folder ID",
            hint: "(Applicable for RLCM) Target environment folder ID to import package into.",
            optional: true
          },                      
          {
            name: "env_type",
            label: "Environment type",
            hint: "(Applicable for Projects) Projects API currently supports only test and prod values.",
            control_type: "select",
            pick_list: "target_environment_types",
            optional: true,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "env_type",
              label: "Environment type",
              type: "string",
              control_type: "text",
              optional: true,
              hint: "(Applicable for Projects) Projects API currently supports only test and prod values.",
              toggle_hint: "Custom value",
            }
          },
          {
            name: "description",
            label: "Description",
            hint: "(Applicable for Projects) Deployment description for documentation.",
            optional: true
          },
          {
            name: "package_content",
            label: "Package Content",
            hint: "(Applicable for RLCM) Optionally provide package to be imported.",
            optional: true
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        
        projects = (input["deployment_mode"] == "projects" ? true : false)
        
        headers = call("get_auth_headers", connection, "#{input["target_environment"]}")   
        
        ## Prepare deployment body ##
        # For RLCM API, download package ID and use it for import
        deploy_body = ""
        if projects.is_true?
          deploy_body = { "description" => input["description"].to_s }
          headers["Content-Type"] = "application/json"
        else
          # Existing package download should always happen from DEV, hence ensure src_env_headers irrespective of API mode
          src_env_headers = call("get_auth_headers", connection, input["src_environment"])
          src_env_datacenter = call("get_environment_datacenter", connection, input["src_environment"])
          deploy_body_param = get("#{src_env_datacenter}/packages/#{input["id"]}/download")          
          .headers(src_env_headers)
          .ignore_redirection               
          .after_error_response(/.*/) do |_code, body, _header, message|
            error("#{message}: #{body}")
          end
          .after_response do |code, body, headers|
            {
              package_url: headers[:location]
            }
          end.response_format_raw
          
          if input["package_content"].present?
            deploy_body = input["package_content"].encode('ASCII-8BIT')
          else
            deploy_body_res = call("download_from_url", {
              "headers" => headers, 
              "workato_environment" => input["src_environment"],
              "download_url" => deploy_body_param[:package_url],
              "package_id" => input["id"],
              "deployment_mode" => input["deployment_mode"] 
            })
            deploy_body = deploy_body_res[:content].encode('ASCII-8BIT')
          end
          headers["Content-Type"] = "application/octet-stream"
        end
        
        ## Deployment of the package ##
        # Projects API - https://docs.workato.com/workato-api/projects.html#deploy-a-project-build
        # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#export-package-based-on-a-manifest
        env_datacenter = call("get_environment_datacenter", connection, input["target_environment"])
        deploy_endpoint = projects ? "#{env_datacenter}/project_builds/#{input["id"]}/deploy?environment_type=#{input["env_type"]}" : "#{env_datacenter}/packages/import/#{input["folder_id"]}?restart_recipes=true"
        
        
        response = post(deploy_endpoint) 
        .headers(headers)
        .request_body(deploy_body)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end

        res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
        #res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
        res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")
        
        {
          status: res_in_progress ? 'in_progress' : (res_success ? 'success' : 'failed'),
          id: response["id"]
        }

      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
          { name: "status" },
          { name: "id" }
        ]
      end
    }, # deploy_package_async.end
    
    get_deployment_package: {
      title: "Get a deployment package",
      subtitle: "Get a deployment package from Workato environment",
      
      help: "Use this action to get a deployment package from selected environment.",
      
      description: lambda do |input| 
        "Get a deployment <span class='provider'>package</span> from " \
        "Workato <span class='provider'>environment</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|
        mode = config_fields['deployment_mode']       
        [
          {
            name: "deployment_mode",
            label: "Deployment Mode",
            control_type: "select",
            pick_list: "deployment_mode",
            optional: false,
            toggle_hint: "Select from list",
            toggle_field: {
              name: "deployment_mode",
              label: "Deployment Mode",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Use Deployment Mode"              
            }
          },          
          {
            name: "deployment_package_id",
            label: "ID",
            hint: "Deployment Package ID",
            optional: false
          },
          {
            label: "Workato environment",
            type: "string",
            name: "workato_environment",
            control_type: "select",
            toggle_hint: "Select from list",
            pick_list: "environments",
            toggle_field: {
              name: "workato_environment",
              label: "Workato environment",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Select environment."
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        
        projects = (input["deployment_mode"] == "projects" ? true : false)
        
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
                        
        # Projects API - https://docs.workato.com/workato-api/projects.html#get-a-deployment
        # RLCM API - https://docs.workato.com/workato-api/recipe-lifecycle-management.html#get-package-by-id
        status_endpoint = projects ? "#{env_datacenter}/deployments/#{input["deployment_package_id"]}" : "#{env_datacenter}/packages/#{input["deployment_package_id"]}"

        response = get(status_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end

        res_in_progress = projects ? (response["state"] == "pending") : (response["status"] == "in_progress")
        #res_failed = projects ? (response["state"] == "failed") : (response["status"] == "failed")
        res_success = projects ? (response["state"] == "success") : (response["status"] == "completed")               

        {
          status: res_in_progress ? 'in_progress' : (res_success ? 'success' : 'failed'),
          id: response["id"],
          project_id: response["project_id"]
          
        }
        
      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
          { name: "status" },
          { name: "id" },
          { name: "project_id" }
        ]
      end
    }, # get_deployment_package.end
    
    list_folders: {
      title: "List folders",
      subtitle: "List folders in Workato environment",
      
      help: "Use this action list folders in the selected environment. Supports up to 100 folders lookup in single action. Repeat this action in recipe for pagination if more than 100 folders lookup is needed.",
      
      description: lambda do |input| 
        "List <span class='provider'>folders</span> in " \
        "<span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| 
        [
          {
            label: "Workato environment",
            type: "string",
            name: "workato_environment",
            control_type: "select",
            toggle_hint: "Select from list",
            pick_list: "environments",
            toggle_field: {
              name: "workato_environment",
              label: "Workato environment",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Select environment."
          },
          {
            name: "parent_id",
            label: "Parent Folder ID",
            optional: true,
            hint: "Please enter parent folder ID",
            type: "string"
          },
          {
            name: "page",
            hint: "Used for pagination.",
            type: "integer",
            default: 1
          }
        ]
      end, 
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        page = input["page"] || 1
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        
        folder_endpoint = "#{env_datacenter}/folders?page=#{page}&per_page=100"
        
        if input['parent_id'].present?
          folder_endpoint = folder_endpoint + "&parent_id=" + input['parent_id']
        end
        
        { folders_list: get(folder_endpoint)
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end }
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        [
          {
            name: "folders_list",
            label: "Folders list",
            control_type: "key_value",
            type: "array",
            of: "object",
            properties: [
              { name: "id" },
              { name: "name" },
              { name: "parent_id" },
              { name: "created_at" },
              { name: "updated_at" }            
            ]
          }
        ]
      end # output_fields.end      
      
    }, # list_folders.end
  
    list_projects: {
      title: "List Projects",
      subtitle: "List Projects in Workato environment",
      
      help: "Use this action to Lists all Projects in the selected Environment. Projects are top level folders. Supports up to 100 Project lookups in single action. Repeat this action in recipe for pagination if more than 100 Project lookups are needed.",
      
      description: lambda do |input| 
        "List <span class='provider'>Projects</span> in <span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| 
        [
          {
            label: "Workato environment",
            type: "string",
            name: "workato_environment",
            control_type: "select",
            toggle_hint: "Select from list",
            pick_list: "environments",
            toggle_field: {
              name: "workato_environment",
              label: "Workato environment",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Select environment."
          },
          {
            name: "page",
            hint: "Used for pagination.",
            type: "integer",
            default: 1
          }
        ]
      end, 
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        page = input["page"] || 1
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        folder_endpoint = "#{env_datacenter}/projects?page=#{page}"
        
        { project_list: get(folder_endpoint)
          .headers(headers)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end }
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        [
          {
            name: "project_list",
            label: "Project List",
            control_type: "key_value",
            type: "array",
            of: "object",
            properties: [
              { name: "id" },
              { name: "description" },
              { name: "folder_id" },
              { name: "name" }
            ]
          }
        ]
      end # output_fields.end      
      
    }, # list_projects.end
  
    create_folder: {
      title: "Create folder",
      subtitle: "Create folder in Workato environment",
      
      help: "Use this action create folder in the selected environment.",
      
      description: lambda do |input| 
        "Create <span class='provider'>folder</span> in " \
        "<span class='provider'>Workato</span>"
      end,
      
      input_fields: lambda do |object_definitions| 
        [
          {
            label: "Workato environment",
            type: "string",
            name: "workato_environment",
            control_type: "select",
            toggle_hint: "Select from list",
            pick_list: "environments",
            toggle_field: {
              name: "workato_environment",
              label: "Workato environment",
              type: "string",
              control_type: "text",
              optional: false,
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Select Environment"
          },
          {
            label: "Folder Name",
            type: "string",
            name: "folder_name",
            control_type: "text",
            optional: false,
            hint: "Enter folder name"
          },
          {
            label: "Parent Folder ID",
            type: "string",
            name: "parent_id",
            control_type: "text",
            optional: true,
            hint: "Enter parent folder ID"
          }
        ]
      end, 
      
      execute: lambda do |connection, input, eis, eos, continue|
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")
        headers['Content-Type'] = 'application/json'
        payload = input["parent_id"].present? ? {"name": input["folder_name"], "parent_id": input["parent_id"]} : {"name": input["folder_name"]}
        
        post("#{env_datacenter}/folders")
        .headers(headers)
        .request_body(payload)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
        
      end, # execute.end
      
      output_fields: lambda do |object_definitions|
        [
          { name: "id" },
          { name: "name" },
          { name: "parent_id" },
          { name: "created_at" },
          { name: "updated_at" }
        ]
      end # output_fields.end      
      
    }, # create_folder.end
  
    upsert_properties: {
      title: "Upsert Account Properties",
      subtitle: "Upsert properties to Workato environment.",
      
      help: "Use this action to upsert properties to the selected environment.",
      
      description: lambda do |input| 
        "Upsert <span class='provider'>properties</span> to " \
        "Workato <span class='provider'>environment</span>"
      end,
      
      input_fields: lambda do |object_definitions, connection, config_fields|        
        [                  
          {
            label: "Environment",
            name: "workato_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter environment."
          },{
            name: "properties",
            label: "Properties",
            hint: "Please enter a list of account properties.",
            optional: false,
            type: "array",
            of: "object",
            properties: [
              { name: "name", optional: false },
              { name: "value", optional: false }
            ]
          },{
            label: "Type",
            name: "type",
            control_type: "text",
            optional: false,
            hint: "Enter type."
          },{
            label: "Project ID",
            name: "project_id",
            control_type: "text",
            optional: true,
            hint: "Enter Project ID."
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")  
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])        
        property_hash = {}
        input['properties'].each do |x|
          property_hash[x[:name]] = x[:value]
        end
  
        property_body = '{"properties":' + property_hash.to_json + '}'
  
        if input['type'] == "environment"
          response = post("#{env_datacenter}/properties")
          .headers(headers)
          .request_body(property_body)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
        elsif input['type'] == "project" && input['project_id'].present?
          response = post("#{env_datacenter}/properties?project_id=#{input['project_id']}")
          .headers(headers)
          .request_body(property_body)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
        end
        
        {          
          result: response["success"]
        }
        
      end, # execute.end
      output_fields: lambda do |connection|
        [ 
          { name: "result", type: "boolean" }
        ]
      end
    }, # upsert_properties.end
  
  get_recipe: {
    title: "Get recipe by Id",
      subtitle: "Get the recipe in a Workato environment.",
      
      help: "Use this action to get a recipe in the selected environment.",
      
      description: lambda do |input| 
        "Get <span class='provider'>recipe</span> in a " \
        "Workato <span class='provider'>environment</span>"
      end,
    
    input_fields: lambda do |object_definitions, connection, config_fields|        
        [                  
          {
            label: "Environment",
            name: "workato_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter environment."
          },
          {
            name: "recipe_id",
            label: "Recipe ID",
            hint: "Returns the specified recipe.",
            optional: true,
            type: "string"
          }
        ]
      end,
    
    execute: lambda do |connection, input, eis, eos, continue|
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")  
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])        
        recipe_endpoint = "#{env_datacenter}/recipes/" + input['recipe_id']
        
        response = get(recipe_endpoint) 
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
              {name: 'id'},
              {name: 'user_id'},
              {name: 'name'},
              {name: 'description'},
              {name: 'folder_id'},
              {name: 'version_no'},
              {name: 'code'},
              {name: 'author_name'},
              {name: 'version_author_name'},
              {name: 'running', type: 'boolean'}
        ]
      end
  }, #get_recipe.end 
  
  update_recipe: {
    title: "Update recipe",
      subtitle: "Update a recipe in a Workato environment.",
      
      help: "Use this action to update a recipe in the selected environment.",
      
      description: lambda do |input| 
        "Update <span class='provider'>recipe</span> in a " \
        "Workato <span class='provider'>environment</span>"
      end,
    
    input_fields: lambda do |object_definitions, connection, config_fields|        
        [                  
          {
            label: "Environment",
            name: "workato_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter environment."
          },
          {
            name: "recipe_id",
            label: "Recipe ID",
            hint: "Returns the specified recipe.",
            optional: true,
            type: "string"
          },
          {
            name: "recipe",
            type: "string"
          }
        ]
      end,
    
    execute: lambda do |connection, input, eis, eos, continue|
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")  
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])        
        recipe_endpoint = "#{env_datacenter}/recipes/" + input['recipe_id']
      
       request_body = input["recipe"].to_json
        
        response = put(recipe_endpoint)
          .request_body(request_body) 
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
              {name: 'success', type: 'boolean'}
        ]
      end
  }, #update_recipe.end 
  
    list_recipes: {
      title: "List all recipes",
      subtitle: "Lists all recipes in a Workato environment.",
      
      help: "Use this action to lists all recipes in the selected environment.",
      
      description: lambda do |input| 
        "List <span class='provider'>recipes</span> in a " \
        "Workato <span class='provider'>environment</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|        
        [                  
          {
            label: "Environment",
            name: "workato_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter environment."
          },
          {
            name: "folder_id",
            label: "Folder ID",
            hint: "Returns list of recipes in the specified folder.",
            optional: true,
            type: "string"
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")  
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])        
        recipe_endpoint = "#{env_datacenter}/recipes"
        
        if input['folder_id'].present?
          recipe_endpoint = recipe_endpoint + "?folder_id=" + input['folder_id']
        end
        
        response = get(recipe_endpoint) 
        .headers(headers)
        .after_error_response(/.*/) do |_, body, _, message|
          error("#{message}: #{body}") 
        end
      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
          {
            name: "items",
            type: "array",
            of: "object",
            properties: [
              {name: 'id'},
              {name: 'name'},
              {name: 'folder_id'},
              {name: 'running', type: 'boolean'}
            ]
          }
        ]
      end
    }, # list_recipes.end
  
    manage_recipes: {
      title: "Manage Recipes",
      subtitle: "Manage recipes in Workato environment.",
      
      help: "Use this action to manage recipes in the selected environment.",
      
      description: lambda do |input| 
        "Manage <span class='provider'>recipes</span> in " \
        "Workato <span class='provider'>environment</span>"
      end,

      input_fields: lambda do |object_definitions, connection, config_fields|        
        [                  
          {
            label: "Environment",
            name: "workato_environment",            
            control_type: "select",
            pick_list: "environments",
            toggle_hint: "Select from list",
            toggle_field: {
              name: "workato_environment",
              label: "Environment",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Enter environment.",
              toggle_hint: "Custom value",
            },             
            optional: false,
            hint: "Enter environment."
          },
          {
            name: "recipe_action",
            label: "Recipe Action",
            hint: "Please select an action",
            optional: false,
            type: "string",
            control_type: "select",
            options: [
              ["Start", "start"],
              ["Stop", "stop"],
              ["Delete", "delete"]
            ],
            toggle_hint: "Select from list",
            toggle_field: {
              name: "recipe_action",
              label: "Recipe Action",
              type: "string",
              control_type: "text",
              optional: false,
              hint: "Please enter a supported action from [start, stop and delete]",
              toggle_hint: "Use Recipe Action"
            }  
          },
          {
            name: "recipe_id",
            label: "Recipe ID",
            hint: "Please enter the recipe ID.",
            optional: false,
            type: "string"
          }
        ]
      end,
      
      execute: lambda do |connection, input, eis, eos, continue|
        
        headers = call("get_auth_headers", connection, "#{input["workato_environment"]}")  
        env_datacenter = call("get_environment_datacenter", connection, input["workato_environment"])
        
        recipe_action = input['recipe_action']
        
        if recipe_action == 'start' || recipe_action == 'stop'        
          response = put("#{env_datacenter}/recipes/#{input['recipe_id']}/#{recipe_action}") 
          .headers(headers)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
        end
        
        if recipe_action == 'delete'
          response = delete("#{env_datacenter}/recipes/#{input['recipe_id']}") 
          .headers(headers)
          .after_error_response(/.*/) do |_, body, _, message|
            error("#{message}: #{body}") 
          end
        end
        
        {          
          result: response["success"]
        }

      end, # execute.end
      
      output_fields: lambda do |connection|
        [ 
          { name: "result", type: "boolean" }
        ]
      end
    } # start_recipes.end
  },

  methods: {
    get_auth_headers: lambda do |connection, env|
      auth_obj = connection["workato_environments"].select { |e| e["name"].include?("#{env}") }
      {
        "Authorization": "Bearer #{auth_obj[0]["api_token"]}"
      }
    end, # get_auth_headers.end
    
    download_from_url: lambda do |input|
      { 
        workato_environment: input["workato_environment"],
        package_id: input["package_id"],
        deployment_mode: input["deployment_mode"],
        content: get(input["download_url"])
          .headers('Accept' => '*/*')
          .after_error_response(/.*/) do |_code, body, _header, message|
            error("#{message}: #{body}")
          end.response_format_raw
      }   
    end, # download_from_url.end
    
    get_target_environments: lambda do |connection, input|
      src_env = input['source_env']
      exclude_prod = input['exclude_prod'].present? && input['exclude_prod'].is_true?
      environments_col = []
      connection['workato_environments'].each do |env|          
        environments_col.push({
          name: env['name'],
          isProduction: env['isProduction'].is_true? ? true : false,
          level: env['level']
        })
      end

      # Filter based on source level
      if src_env.present?
        source_env_detail = environments_col.where(name: src_env).first
        if source_env_detail.present?
          if source_env_detail[:isProduction].is_true?
            environments_col = environments_col.where(isProduction: false)
          else
            environments_col = environments_col.where(level: (source_env_detail[:level].to_i + 1))
          end        
        end
      end
      if exclude_prod.is_true?
        environments_col.where('isProduction !=': true)
      else  
        environments_col
      end
    end, # get_target_environments.end
    
    # Get environment data center
    get_environment_datacenter: lambda do |connection, environment|
      env_data_center = ""
      env_detail = connection['workato_environments'].where(name: environment).first
      if env_detail.present?
        env_data_center = env_detail['data_center']
      end
      env_data_center
    end, # get_environment_datacenter.end
    
    # Validation during test connection
    connection_validation: lambda do |workato_environments|
      # Check if there are more than 2 production environments
      if workato_environments.where(isProduction: 'true').length > 1
         error('More than one production environment isn\'t allowed.')
      end
    
      # Check if two environments have same name
      env_names = workato_environments.pluck('name').map do |env| env.upcase end
      env_names_uniq = env_names.uniq
      if env_names.length != env_names_uniq.length
        error('Environment name must be unique.')
      end
    
      ## Validations related to "Level"
      env_levels = workato_environments.pluck('level').map do |lvl| lvl.to_i end
      env_levels_min = env_levels.min
      # Check if levels are empty
      if env_levels_min == 0
        error('Level cannot be empty.')
      end
    
      # Check if levels are not starting with 1
      if env_levels_min != 1
        error('Starting level is missing.')
      end
    
      # Check if levels are sequential
      check_lvl = env_levels_min
        env_levels.sort.each do |lvl|
          if lvl > check_lvl + 1
            error('Levels not in allowed sequence. Eg.:[1,2,3], [1,2,2], [1,1,2]')
          end
          check_lvl = lvl
        end
      end #connection_validation.end
       
  },

  pick_lists: {
    deployment_mode: lambda do
      [
        %w[Projects\ (Environments) projects],
        %w[Recipe\ Lifecycle\ Management rlcm]
      ]
    end,
    
    environments: lambda do |connection| 
      connection["workato_environments"].map do |env|
        ["#{env["name"]}", "#{env["name"]}"]
      end
    end,
    
    target_environments: lambda do |connection, src_environment:|
      input = {}
      input['source_env'] = src_environment
      call("get_target_environments", connection, input).map do |env|
        ["#{env[:name]}", "#{env[:name]}"]
      end
    end,
    
    target_environment_types: lambda do
      [
        %w[Test test],
        %w[Production prod]
      ]
    end
  }
}